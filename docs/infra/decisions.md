# Вопросы и решения по инфраструктуре

## Container registry

Раньше использовали GitLab Container Registry.

Две проблемы:

1) При сборке на кластере через kaniko GitLab тормозит. (Kaniko заливает и скачивает образы при каждой сборке, потому что пока что не умеет в локальный кеш для промежуточных слоёв).
2) У GitLab'а есть лимит на размер хранилища, и при частой пересборке его может не хватить.

**Решение: в будущем поднять приватный container registry, пока что остаться на GitLab'е.**

## Сборка

skaffold позволяет собирать образы [несколькими разными способами](https://skaffold.dev/docs/pipeline-stages/builders/docker/):
- локально
- в своём кластер через [kaniko](https://github.com/GoogleContainerTools/kaniko)
- через google cloud build

Использовать google cloud build я не хочу, локальная сборка тормозит у меня и может быть слишком ресурсозатратной для других разработчиков.

Kaniko тормозит тоже :(

1) часто пересобирает слой, даже если ничего не изменилось (почему?)
2) долго делает snapshot

Возможные варианты решения:
- поднять собственный container registry, чтобы kaniko работал быстрее (см. выше)
- включить [mtime snapshots](https://github.com/GoogleContainerTools/kaniko#mtime-and-snapshotting) (в доках указано, что это может быть теоретически небезопасно, но непонятно, насколько)
- отказаться от kaniko в пользу сборки на удалённом сервере с поднятым обычным docker'ом (без kubernetes)

**Решение: использовать локальную сборку, пока не будет готов локальный кеш в kaniko.**

## Разделение разработки и продакшна

Хочется:

- Сэкономить на ресурсах
- Запускать контейнеры при разработке в облаке
- Не убивать при этом продакшн

Варианты решения:
1) делить неймспейсы аккуратно по нодам с помощью nodeSelector, PodNodeSelector или affinity-настроек
2) не делить вообще, контролировать всё с помощью resource requests & limits
3) поднять отдельный k3s из одного инстанса

Плюсы первого варианта: меньше ресурсов (два мастера k3s едят вдвое больше памяти).

Плюсы второго варианта: максимальная утилизация ресурсов.

Плюсы третьего варианта:
- все пишут, что так правильно делать и не надо мешать dev и prod
- можно безопасно пускать в dev других людей
- можно не бояться, что забуду сконфигурировать nodeSelector и что-то критическое запустится на dev-ноде

**Решение: использовать два кластера.**
