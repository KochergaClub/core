Пишем всё на React и TypeScript.

Отдельные интерфейсы (в частности, [форма брони](https://booking.kocherga.club) и [Evenman](https://evenman.team.kocherga.club)) пока что живут в отдельном lerna-моно-репозитории [kocherga/core/frontend](https://gitlab.com/kocherga/code/frontend). В будущем они (все, кроме frontkit) тоже переедут в core.

# Организация файлов

Весь фронтенд-код располагается в директории `jsx`.

Если директория не указана ниже, то скорее всего это директория "приложения". По аналогии с Django-приложениями, каждое приложение отвечает за отдельный аспект сайта.

## Корневые директории

* core - общие для всех страниц Redux actions, selectors, reducer
* redux - корневой redux reducer и store (использует store и другие приложения, пока что все, но в будущем предполагается условное подключение только тех приложений, нужных для текущей страницы)
* components/ - общие React-компоненты
* common/ - общий JS-код, не специфичный для React'а или Redux'а
* common/hooks/ - React hooks
* pages/ - NextJS pages
* wagtail/ - особое приложение с общими компонентами wagtail-блоков и страниц (но многие специфичные компоненты блоков и страниц переезжают в директории приложений)
* render/ - серверный код для SSR и роутинга

# Организация файлов в приложении
* `api.ts` - функции-обёртки, вызывающие кочерговое API (устаревает в пользу actions.ts).
* `actions.ts` - Redux actions.
* `reducer.ts` - Redux reducer.
* `selectors.ts` - Redux selectors.
* `slices.ts` - высокоуровневые redux-модули для переиспользования общего кода; описаны в `/redux/slices/*`.
* `components/` - общие React-компоненты.
* `types.ts` - TypeScript-типы.
* `contexts.ts` - React Contexts. Устаревает в пользу Redux.
* `pages/` - отдельные NextJS-страницы (используются из NextJS-страниц).
* `wagtail/` - Wagtail-страницы (импортируются в /pages/wagtail-any.tsx).

# State management

Я перепробовал несколько разных подходов к управлению стейтом на фронтенде:

* Evenman использует MobX
* core использует useReducer
* Redux

Сейчас (август-сентябрь 2019) постепенно переношу всё на Redux, но поглядываю в сторону GraphQL.

## Почему Redux?

`useReducer` в каждом отдельном приложении (watchmen, events) и пробрасывание dispatch в специфичном для приложения контексте было бы _почти что_ работающей и хорошей идеей.

Пока что нашлась одна причина так не делать:

* Хочется делать action creators, а не просто передавать actions (это решаемо, `dispatch(createAction())` устроен одинаково хоть в useReducer, хоть в Redux).
* Ещё хочется делать асинхронные action creators, аналогичные redux thunks (это [https://blog.solutelabs.com/configuring-thunk-action-creators-and-redux-dev-tools-with-reacts-usereducer-hook-5a1608476812](тоже решаемо)).
* Но ещё хочется предзагружать стейт на сервере, в `getInitialProps`; проблема в том, что `getInitialProps` работает вне контекста компонента, поэтому вызвать там асинхронный `dispatch(reloadSomeData())` невозможно.

С другой стороны, у прямолинейного использования redux'а есть недостатки:

* reducer общий на все приложения, и поэтому при SSR в preloadedState при наивной реализации попадут все ключи, в том числе от /team/* приложений; чтобы этого избежать, придётся подменять reducer для каждой nextjs-страницы, вероятно трекая зависимости для каждой страницы вручную
** и ещё есть вариант вместо этого хранить undefined стейт по умолчанию, писать аккуратные selector'ы и заполнять state только по мере необходимости
** не то чтобы это _совсем_ блокер, но палить названия всех внутренних приложений в коде всех страниц как-то сильно неэстетично
* redux требует большого коммитмента

## Может, лучше GraphQL?
GraphQL (в его инкарнации apollo-graphql с react-хуками) выглядит очень удобно.

Что пока что останавливает:
* переезд на GraphQL - это ещё один _большой_ рефакторинг
* graphene-django выглядит сыровато в плане (1) разграничения прав доступа; (2) проблемы [N+1 запросов](https://github.com/graphql-python/graphene-django/issues/57)

# Недостатки фронтенда

## Отсутствие тестов
Пора научиться их писать.
